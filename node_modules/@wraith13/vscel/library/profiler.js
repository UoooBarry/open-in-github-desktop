"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.debug = exports.getReport = exports.getOverall = exports.stop = exports.start = exports.getIsProfiling = exports.profile = exports.ProfileEntry = exports.percentToDisplayString = exports.roundCenti = exports.getTicks = void 0;
exports.getTicks = () => new Date().getTime();
exports.roundCenti = (value) => Math.round(value * 100) / 100;
exports.percentToDisplayString = (value, locales) => `${exports.roundCenti(value).toLocaleString(locales, { style: "percent" })}`;
let profileScore = {};
let entryStack = [];
let isProfiling = false;
let startAt = 0;
let endAt = 0;
let debugCount = 0;
class ProfileEntry {
    constructor(name) {
        this.name = name;
        this.childrenTicks = 0;
        if (isProfiling) {
            this.startTicks = exports.getTicks();
            entryStack.push(this);
            if (this.name.startsWith("DEBUG:")) {
                ++debugCount;
            }
            exports.debug(`${"*".repeat(entryStack.length)} ${this.name} begin`);
        }
        else {
            this.startTicks = 0;
        }
    }
    end() {
        if (0 !== this.startTicks) {
            exports.debug(`${"*".repeat(entryStack.length)} ${this.name} end`);
            if (this.name.startsWith("DEBUG:")) {
                --debugCount;
            }
            const wholeTicks = exports.getTicks() - this.startTicks;
            if (undefined === profileScore[this.name]) {
                profileScore[this.name] = 0;
            }
            profileScore[this.name] += wholeTicks - this.childrenTicks;
            entryStack.pop();
            if (0 < entryStack.length) {
                entryStack[entryStack.length - 1].childrenTicks += wholeTicks;
            }
        }
    }
}
exports.ProfileEntry = ProfileEntry;
exports.profile = (name, target) => {
    const entry = new ProfileEntry(name);
    try {
        return target();
    }
    catch (error) // 現状(VS Code v1.32.3)、こうしておかないとデバッグコンソールに例外情報が出力されない為の処置。
     {
        console.error(`Exception at: ${name}`);
        console.error(error);
        throw error; // ※この再送出により外側のこの関数で再び catch し重複してエラーが出力されることに注意。
    }
    finally {
        entry.end();
    }
};
exports.getIsProfiling = () => isProfiling;
exports.start = () => {
    isProfiling = true;
    profileScore = {};
    entryStack = [];
    startAt = exports.getTicks();
};
exports.stop = () => {
    isProfiling = false;
    endAt = exports.getTicks();
};
exports.getOverall = () => (isProfiling ? exports.getTicks() : endAt) - startAt;
exports.getReport = () => Object.keys(profileScore)
    .map(name => ({
    name,
    ticks: profileScore[name]
}))
    .sort((a, b) => b.ticks - a.ticks);
exports.debug = (text, object) => {
    if (0 < debugCount) {
        if (undefined !== object) {
            console.log(text);
        }
        else {
            console.log(`${text}: ${JSON.stringify(object)}`);
        }
    }
};
//# sourceMappingURL=profiler.js.map